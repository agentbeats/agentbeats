<script lang="ts" module>import { getContext, setContext } from "svelte";
import {
  Action,
  useReducer,
  InternalContextKey,
  PublicContextKey
} from "../../store/index.js";
import { DndMonitorContextKey, useDndMonitorProvider } from "../dnd-monitor/index.js";
import { defaultData, defaultSensors } from "./defaults.js";
import {
  adjustScale,
  getAdjustedRect,
  getFirstCollision,
  rectIntersection
} from "../../utilities/index.js";
import { applyModifiers } from "../../modifiers/index.js";
import { add, getEventCoordinates, getWindow, useUniqueId } from "@dnd-kit-svelte/utilities";
import { useLayoutShiftScrollCompensation, useMeasuringConfiguration } from "./hooks/index.js";
import {
  useAutoScroller,
  useCachedNode,
  useCombineActivators,
  useDragOverlayMeasuring,
  useDroppableMeasuring,
  useInitialRect,
  useRect,
  useRectDelta,
  useRects,
  useScrollableAncestors,
  useScrollOffsets,
  useScrollOffsetsDelta,
  useSensorSetup,
  useWindowRect
} from "../../hooks/utilities/index.js";
import { watch } from "runed";
import { Accessibility, RestoreFocus } from "../accessibility/index.js";
export const ActiveDraggableContextKey = Symbol("ActiveDraggableContext");
export function getActiveDraggableContext() {
  return getContext(ActiveDraggableContextKey)();
}
var Status = /* @__PURE__ */ ((Status2) => {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
  return Status2;
})(Status || {});
</script>

<script lang="ts">let {
  id,
  accessibility,
  autoScroll = true,
  children,
  sensors = defaultSensors,
  collisionDetection = rectIntersection,
  measuring,
  modifiers,
  ...latestProps
} = $props();
const [ctxState, dispatch] = useReducer();
const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
let status = $state(Status.Uninitialized);
const isInitialized = $derived(status === Status.Initialized);
const {
  draggable: { active: activeId, nodes: draggableNodes, translate },
  droppable: { containers: droppableContainers }
} = $derived(ctxState);
const node = $derived(activeId != null ? draggableNodes.get(activeId) : null);
const activeRects = $state({
  initial: null,
  translated: null
});
const active = $derived(
  activeId != null ? {
    id: activeId,
    // It's possible for the active node to unmount while dragging
    data: node?.data ?? defaultData,
    rect: activeRects
  } : null
);
let activeRef = null;
let activeSensor = $state(null);
let activatorEvent = $state(null);
const draggableDescribedById = $derived(useUniqueId(`DndDescribedBy`, id));
const enabledDroppableContainers = $derived(droppableContainers.getEnabled());
const measuringConfiguration = $derived(useMeasuringConfiguration(measuring));
const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(() => ({
  containers: enabledDroppableContainers,
  dragging: isInitialized,
  dependencies: () => [translate.x, translate.y],
  config: measuringConfiguration.droppable
}));
const activeNode = useCachedNode(() => [draggableNodes, activeId]);
const activationCoordinates = $derived(activatorEvent ? getEventCoordinates(activatorEvent) : null);
const autoScrollOptions = $derived(getAutoScrollerOptions());
const initialActiveNodeRect = useInitialRect(
  () => activeNode.current,
  () => measuringConfiguration.draggable.measure
);
useLayoutShiftScrollCompensation(() => ({
  activeNode: activeId != null ? draggableNodes.get(activeId) : null,
  config: autoScrollOptions.layoutShiftCompensation,
  initialRect: initialActiveNodeRect.current,
  measure: measuringConfiguration.draggable.measure
}));
const activeNodeRect = useRect(() => [
  activeNode.current,
  measuringConfiguration.draggable.measure,
  initialActiveNodeRect.current
]);
const containerNodeRect = useRect(() => [activeNode.current ? activeNode.current.parentElement : null]);
const sensorContext = $state({
  activatorEvent: null,
  active: null,
  activeNode: activeNode.current,
  collisionRect: null,
  collisions: null,
  droppableRects: droppableRects.current,
  // svelte-ignore state_referenced_locally
  draggableNodes,
  draggingNode: null,
  draggingNodeRect: null,
  // svelte-ignore state_referenced_locally
  droppableContainers,
  over: null,
  scrollableAncestors: [],
  scrollAdjustedTranslate: null
});
const overNode = $derived(droppableContainers.getNodeFor(sensorContext.over?.id));
const dragOverlay = useDragOverlayMeasuring({
  measureFn: () => measuringConfiguration.dragOverlay.measure
});
const draggingNode = $derived(dragOverlay.nodeRef ? dragOverlay.nodeRef : activeNode.current);
const draggingNodeRect = $derived(isInitialized ? dragOverlay.rect ?? activeNodeRect.current : null);
const usesDragOverlay = $derived(Boolean(dragOverlay.nodeRef && dragOverlay.rect));
const nodeRectDelta = useRectDelta(() => usesDragOverlay ? null : activeNodeRect.current);
const windowRect = useWindowRect(() => draggingNode ? getWindow(draggingNode) : null);
const scrollableAncestors = useScrollableAncestors(() => isInitialized ? overNode ?? activeNode.current : null);
const scrollableAncestorRects = useRects(() => [scrollableAncestors.current]);
const modifiedTranslate = $derived(
  applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.current.x,
      y: translate.y - nodeRectDelta.current.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect: activeNodeRect.current,
    containerNodeRect: containerNodeRect.current,
    draggingNodeRect,
    over: sensorContext.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors: scrollableAncestors.current,
    scrollableAncestorRects: scrollableAncestorRects.current,
    windowRect: windowRect.current
  })
);
const pointerCoordinates = $derived(activationCoordinates ? add(activationCoordinates, translate) : null);
const scrollOffsets = useScrollOffsets(() => scrollableAncestors.current);
const scrollAdjustment = useScrollOffsetsDelta(() => [scrollOffsets.current]);
const activeNodeScrollDelta = useScrollOffsetsDelta(() => [scrollOffsets.current, [activeNodeRect.current]]);
const scrollAdjustedTranslate = $derived(add(modifiedTranslate, scrollAdjustment.current));
const collisionRect = $derived(draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null);
const collisions = $derived(
  active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects: droppableRects.current,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null
);
const overId = $derived(getFirstCollision(collisions, "id"));
let over = $state(null);
const appliedTranslate = $derived(
  usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta.current)
);
const transform = $derived(adjustScale(appliedTranslate, over?.rect ?? null, activeNodeRect.current));
let activeSensorRef = null;
const instantiateSensor = (event, { sensor: Sensor, options }) => {
  if (activeRef == null) {
    return;
  }
  const activeNode2 = draggableNodes.get(activeRef);
  if (!activeNode2) {
    return;
  }
  const localActivatorEvent = event;
  const sensorInstance = new Sensor({
    active: activeRef,
    activeNode: activeNode2,
    event: localActivatorEvent,
    options,
    // Sensors need to be instantiated with $state as a Proxy for arguments that change over time
    // otherwise they are frozen in time with the stale arguments
    context: sensorContext,
    onAbort(id2) {
      const draggableNode = draggableNodes.get(id2);
      if (!draggableNode) {
        return;
      }
      const { onDragAbort } = latestProps;
      const event2 = { id: id2 };
      onDragAbort?.(event2);
      dispatchMonitorEvent({ type: "onDragAbort", event: event2 });
    },
    onPending(id2, constraint, initialCoordinates, offset) {
      const draggableNode = draggableNodes.get(id2);
      if (!draggableNode) {
        return;
      }
      const { onDragPending } = latestProps;
      const event2 = {
        id: id2,
        constraint,
        initialCoordinates,
        offset
      };
      onDragPending?.(event2);
      dispatchMonitorEvent({ type: "onDragPending", event: event2 });
    },
    onStart(initialCoordinates) {
      const id2 = activeRef;
      if (id2 == null) {
        return;
      }
      const draggableNode = draggableNodes.get(id2);
      if (!draggableNode) {
        return;
      }
      const { onDragStart } = latestProps;
      const event2 = {
        activatorEvent: localActivatorEvent,
        active: { id: id2, data: draggableNode.data, rect: activeRects }
      };
      onDragStart?.(event2);
      status = Status.Initializing;
      dispatch({
        type: Action.DragStart,
        initialCoordinates,
        active: id2
      });
      dispatchMonitorEvent({ type: "onDragStart", event: event2 });
      activeSensor = activeSensorRef;
      activatorEvent = localActivatorEvent;
    },
    onMove(coordinates) {
      dispatch({
        type: Action.DragMove,
        coordinates
      });
    },
    onEnd: createHandler(Action.DragEnd),
    onCancel: createHandler(Action.DragCancel)
  });
  activeSensorRef = sensorInstance;
  function createHandler(type) {
    return async function handler() {
      const { active: active2, collisions: collisions2, over: localOver, scrollAdjustedTranslate: scrollAdjustedTranslate2 } = sensorContext;
      let event2 = null;
      if (active2 && scrollAdjustedTranslate2) {
        const { cancelDrop } = latestProps;
        event2 = {
          activatorEvent: localActivatorEvent,
          active: active2,
          collisions: collisions2,
          delta: scrollAdjustedTranslate2,
          over: localOver
        };
        if (type === Action.DragEnd && typeof cancelDrop === "function") {
          const shouldCancel = await Promise.resolve(cancelDrop(event2));
          if (shouldCancel) {
            type = Action.DragCancel;
          }
        }
      }
      activeRef = null;
      dispatch({ type });
      status = Status.Uninitialized;
      over = null;
      activeSensor = null;
      activatorEvent = null;
      activeSensorRef = null;
      const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
      if (event2) {
        const handler2 = latestProps[eventName];
        handler2?.(event2);
        dispatchMonitorEvent({ type: eventName, event: event2 });
      }
    };
  }
};
const bindActivatorToSensorInstantiator = (handler, sensor) => {
  return (event, active2) => {
    const nativeEvent = event;
    const activeDraggableNode = draggableNodes.get(active2);
    if (
      // Another sensor is already instantiating
      activeRef !== null || // No active draggable
      !activeDraggableNode || // Event has already been captured
      nativeEvent.dndKit || nativeEvent.defaultPrevented
    ) {
      return;
    }
    const activationContext = {
      active: activeDraggableNode
    };
    const shouldActivate = handler(event, sensor.options, activationContext);
    if (shouldActivate === true) {
      nativeEvent.dndKit = {
        capturedBy: sensor.sensor
      };
      activeRef = active2;
      instantiateSensor(event, sensor);
    }
  };
};
const activators = useCombineActivators(() => [sensors, bindActivatorToSensorInstantiator]);
useSensorSetup(() => sensors);
$effect(() => {
  if (activeNodeRect.current && status === Status.Initializing) {
    status = Status.Initialized;
  }
});
watch(
  () => scrollAdjustedTranslate,
  () => {
    const { onDragMove } = latestProps;
    const { active: active2, activatorEvent: activatorEvent2, collisions: collisions2, over: over2 } = sensorContext;
    if (!active2 || !activatorEvent2) {
      return;
    }
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    onDragMove?.(event);
    dispatchMonitorEvent({ type: "onDragMove", event });
  }
);
watch(
  () => overId,
  () => {
    const { active: active2, activatorEvent: activatorEvent2, collisions: collisions2, droppableContainers: droppableContainers2, scrollAdjustedTranslate: scrollAdjustedTranslate2 } = sensorContext;
    if (!active2 || activeRef == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
      return;
    }
    const { onDragOver } = latestProps;
    const overContainer = droppableContainers2.get(overId);
    const localOver = overContainer && overContainer.rect ? {
      id: overContainer.id,
      rect: overContainer.rect,
      data: overContainer.data,
      disabled: overContainer.disabled
    } : null;
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate2.x,
        y: scrollAdjustedTranslate2.y
      },
      over: localOver
    };
    over = localOver;
    onDragOver?.(event);
    dispatchMonitorEvent({ type: "onDragOver", event });
  }
);
$effect(() => {
  Object.assign(sensorContext, {
    activatorEvent,
    active,
    activeNode: activeNode.current,
    collisionRect,
    collisions,
    droppableRects: droppableRects.current,
    draggableNodes,
    draggingNode,
    draggingNodeRect,
    droppableContainers,
    over,
    scrollableAncestors: scrollableAncestors.current,
    scrollAdjustedTranslate
  });
  Object.assign(activeRects, {
    initial: draggingNodeRect,
    translated: collisionRect
  });
});
useAutoScroller(() => ({
  ...autoScrollOptions,
  delta: translate,
  draggingRect: collisionRect,
  pointerCoordinates,
  scrollableAncestors: scrollableAncestors.current,
  scrollableAncestorRects: scrollableAncestorRects.current
}));
const publicContext = $derived({
  active,
  activeNode: activeNode.current,
  activeNodeRect: activeNodeRect.current,
  activatorEvent,
  collisions,
  containerNodeRect: containerNodeRect.current,
  dragOverlay,
  draggableNodes,
  droppableContainers,
  droppableRects: droppableRects.current,
  over,
  measureDroppableContainers,
  scrollableAncestors: scrollableAncestors.current,
  scrollableAncestorRects: scrollableAncestorRects.current,
  measuringConfiguration,
  measuringScheduled: measuringScheduled.current,
  windowRect: windowRect.current
});
const internalContext = $derived({
  activatorEvent,
  activators: activators.current,
  active,
  activeNodeRect: activeNodeRect.current,
  ariaDescribedById: {
    draggable: draggableDescribedById
  },
  dispatch,
  draggableNodes,
  over,
  measureDroppableContainers
});
function getAutoScrollerOptions() {
  const activeSensorDisablesAutoscroll = activeSensor?.autoScrollEnabled === false;
  const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
  const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
  if (typeof autoScroll === "object") {
    return {
      ...autoScroll,
      enabled
    };
  }
  return { enabled };
}
setContext(DndMonitorContextKey, registerMonitorListener);
setContext(InternalContextKey, () => internalContext);
setContext(PublicContextKey, () => publicContext);
setContext(ActiveDraggableContextKey, () => transform);
</script>

{@render children?.()}
<RestoreFocus disabled={accessibility?.restoreFocus === false} />
<Accessibility {...accessibility} hiddenTextDescribedById={draggableDescribedById} />
