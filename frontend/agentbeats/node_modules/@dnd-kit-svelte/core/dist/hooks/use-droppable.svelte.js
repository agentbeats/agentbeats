import { Action, getInternalContext } from '../store/index.js';
import { unwrapResolvableObject, useNodeRef, useUniqueId } from '@dnd-kit-svelte/utilities';
import { watch } from 'runed';
import { useResizeObserver } from './utilities/index.js';
import { box } from 'svelte-toolbelt';
const ID_PREFIX = 'Droppable';
const defaultResizeObserverConfig = {
    timeout: 25,
};
export function useDroppable(args) {
    const key = useUniqueId(ID_PREFIX);
    const { id, disabled = false, data, resizeObserverConfig } = $derived(unwrapResolvableObject(args));
    const { active, dispatch, over, measureDroppableContainers } = $derived(getInternalContext());
    const previous = { disabled };
    let resizeObserverConnected = false;
    const rect = null;
    let callbackId = null;
    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout, } = $derived({
        ...defaultResizeObserverConfig,
        ...resizeObserverConfig,
    });
    const ids = $derived(updateMeasurementsFor ?? id);
    const handleResize = () => {
        if (!resizeObserverConnected) {
            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,
            // assuming the element is rendered and displayed.
            resizeObserverConnected = true;
            return;
        }
        if (callbackId != null) {
            clearTimeout(callbackId);
        }
        callbackId = setTimeout(() => {
            measureDroppableContainers(Array.isArray(ids) ? ids : [ids]);
            callbackId = null;
        }, resizeObserverTimeout);
    };
    const resizeObserver = useResizeObserver(() => ({
        callback: handleResize,
        disabled: resizeObserverDisabled || !active,
    }));
    const handleNodeChange = (newElement, previousElement) => {
        if (!resizeObserver.current) {
            return;
        }
        if (previousElement) {
            resizeObserver.current.unobserve(previousElement);
            resizeObserverConnected = false;
        }
        if (newElement) {
            resizeObserver.current.observe(newElement);
        }
    };
    const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
    $effect(() => {
        if (!resizeObserver.current || !nodeRef.current) {
            return;
        }
        resizeObserver.current.disconnect();
        resizeObserverConnected = false;
        resizeObserver.current.observe(nodeRef.current);
    });
    watch(() => id, () => {
        dispatch({
            type: Action.RegisterDroppable,
            element: {
                id,
                key,
                disabled,
                node: nodeRef.current,
                rect,
                data,
            },
        });
        return () => {
            dispatch({
                type: Action.UnregisterDroppable,
                key,
                id,
            });
        };
    });
    $effect(() => {
        if (disabled !== previous.disabled) {
            dispatch({
                type: Action.SetDroppableDisabled,
                id,
                key,
                disabled,
            });
            previous.disabled = disabled;
        }
    });
    return {
        active: box.with(() => active),
        rect: box.with(() => rect),
        isOver: box.with(() => over?.id === id),
        node: nodeRef,
        over: box.with(() => over),
        setNodeRef,
    };
}
