<script lang="ts" module>import { NullifiedContextProvider } from "./components/nullified-context-provider/index.js";
import { PositionedOverlay } from "./components/positioned-overlay/index.js";
import { getActiveDraggableContext } from "../dnd-context/dnd-context.svelte";
import { useDndContext } from "../../hooks/index.js";
import { applyModifiers } from "../../index.js";
import { useInitialValue } from "../../hooks/utilities/index.js";
import { useDropAnimation } from "./hooks/index.js";
</script>

<script lang="ts">let {
  adjustScale = false,
  children,
  dropAnimation: dropAnimationConfig,
  style,
  transition,
  modifiers,
  wrapperElement = "div",
  className,
  zIndex = 999
} = $props();
const {
  activatorEvent,
  active,
  activeNodeRect,
  containerNodeRect,
  draggableNodes,
  droppableContainers,
  dragOverlay,
  over,
  measuringConfiguration,
  scrollableAncestors,
  scrollableAncestorRects,
  windowRect
} = $derived(useDndContext());
const transform = $derived(getActiveDraggableContext());
const modifiedTransform = $derived(
  applyModifiers(modifiers, {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect: dragOverlay.rect,
    over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    transform,
    windowRect
  })
);
const initialRect = useInitialValue(() => activeNodeRect);
const dropAnimation = $derived(
  useDropAnimation({
    config: dropAnimationConfig,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  })
);
let ghostElement;
let previousActiveId;
let onStylesUpdated = $state(() => {
});
function cleanup() {
  ghostElement?.remove();
  ghostElement = void 0;
  previousActiveId = void 0;
  onStylesUpdated = () => {
  };
}
function handleExit(overlayNode) {
  $effect(() => {
    ghostElement = overlayNode.cloneNode(true);
    previousActiveId = active?.id;
    onStylesUpdated = (styles) => {
      ghostElement.style.cssText = styles;
    };
    return () => {
      if (!ghostElement || !previousActiveId) return cleanup();
      document.body.appendChild(ghostElement);
      Promise.resolve(dropAnimation(previousActiveId, ghostElement)).then(cleanup);
    };
  });
}
</script>

<NullifiedContextProvider>
	{#if active}
		{#key active.id}
			<PositionedOverlay
				id={active.id}
				bind:ref={() => null,
				(el) => {
					// We need to wait for the active node to be measured before connecting the drag overlay ref
					// otherwise collisions can be computed against a mispositioned drag overlay
					if (initialRect.current) {
						dragOverlay.setRef(el);
					}
				}}
				as={wrapperElement}
				{activatorEvent}
				{adjustScale}
				{className}
				{transition}
				rect={initialRect.current}
				style={{
					zIndex,
					...style,
				}}
				transform={modifiedTransform}
				{handleExit}
				{onStylesUpdated}
			>
				{@render children?.()}
			</PositionedOverlay>
		{/key}
	{/if}
</NullifiedContextProvider>
