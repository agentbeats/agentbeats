import { box } from 'svelte-toolbelt';
import { Rect } from '../../utilities/rect/index.js';
import { untrack } from 'svelte';
import { useLazyMemo } from '@dnd-kit-svelte/utilities';
export var MeasuringStrategy;
(function (MeasuringStrategy) {
    MeasuringStrategy[MeasuringStrategy["Always"] = 0] = "Always";
    MeasuringStrategy[MeasuringStrategy["BeforeDragging"] = 1] = "BeforeDragging";
    MeasuringStrategy[MeasuringStrategy["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
export var MeasuringFrequency;
(function (MeasuringFrequency) {
    MeasuringFrequency["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = new Map();
export function useDroppableMeasuring(options) {
    const { containers, dragging, dependencies, config: { measure, strategy, frequency }, } = $derived(options());
    let queue = $state(null);
    let containersRef = containers;
    const disabled = $derived(isDisabled());
    const measureDroppableContainers = (ids = []) => {
        if (disabled)
            return;
        queue = queue === null ? ids : queue.concat(ids.filter((id) => !queue.includes(id)));
    };
    let timeoutId = null;
    const droppableRects = useLazyMemo((previousValue) => {
        if (disabled && !dragging) {
            return defaultValue;
        }
        if (!previousValue || previousValue === defaultValue || containersRef !== containers || queue != null) {
            const map = new Map();
            for (const container of containers) {
                if (!container) {
                    continue;
                }
                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect) {
                    // This container does not need to be re-measured
                    map.set(container.id, container.rect);
                    continue;
                }
                const node = container.node;
                const rect = node ? new Rect(measure(node), node) : null;
                container.rect = rect;
                if (rect) {
                    map.set(container.id, rect);
                }
            }
            return map;
        }
        return previousValue;
    });
    $effect(() => {
        containersRef = containers;
    });
    $effect(() => {
        void dragging; // trigger re-run
        if (disabled)
            return;
        untrack(measureDroppableContainers);
    });
    $effect(() => {
        if (queue && queue.length > 0) {
            queue = null;
        }
    });
    $effect(() => {
        dependencies(); // trigger re-run
        if (disabled || typeof frequency !== 'number' || timeoutId !== null) {
            return;
        }
        timeoutId = setTimeout(() => {
            measureDroppableContainers();
            timeoutId = null;
        }, frequency);
    });
    return {
        droppableRects: box.with(() => droppableRects.current),
        measureDroppableContainers,
        measuringScheduled: box.with(() => queue !== null),
    };
    function isDisabled() {
        switch (strategy) {
            case MeasuringStrategy.Always:
                return false;
            case MeasuringStrategy.BeforeDragging:
                return dragging;
            default:
                return !dragging;
        }
    }
}
